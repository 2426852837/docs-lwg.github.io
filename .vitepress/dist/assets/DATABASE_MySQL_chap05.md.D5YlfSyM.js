import{_ as l,c as a,o as t,a1 as e}from"./chunks/framework.BzbwRryB.js";const _=JSON.parse('{"title":"全局锁和表锁","description":"","frontmatter":{},"headers":[],"relativePath":"DATABASE/MySQL/chap05.md","filePath":"DATABASE/MySQL/chap05.md"}'),o={name:"DATABASE/MySQL/chap05.md"},r=e('<h1 id="全局锁和表锁" tabindex="-1">全局锁和表锁 <a class="header-anchor" href="#全局锁和表锁" aria-label="Permalink to &quot;全局锁和表锁&quot;">​</a></h1><h2 id="全局锁" tabindex="-1">全局锁 <a class="header-anchor" href="#全局锁" aria-label="Permalink to &quot;全局锁&quot;">​</a></h2><p>全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。</p><ul><li><p><strong>全局锁的典型使用场景是，做全库逻辑备份，即</strong>把整库每个表都select出来存成文本</p><ul><li><p>在备份过程中，整个库完全处于只读状态</p></li><li><p>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</p></li><li><p>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</p></li></ul></li><li><p>但<strong>不加锁进行备份</strong>的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。</p></li><li><p>需要在可重复读隔离级别下开启一个事务</p></li><li><p>官方自带的逻辑备份工具是<strong>mysqldump</strong>。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。</p></li><li><p><strong>single-transaction方法只适用于所有的表使用事务引擎的库（MyISAM引擎不支持事务）</strong></p></li></ul><h3 id="为什么不采用set-global-readonly-true的方式来让全库只读" tabindex="-1">为什么不采用<strong>set global readonly=true的方式来让全库只读</strong> <a class="header-anchor" href="#为什么不采用set-global-readonly-true的方式来让全库只读" aria-label="Permalink to &quot;为什么不采用**set global readonly=true的方式来让全库只读**&quot;">​</a></h3><ul><li><p>在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，不建议使用</p></li><li><p>在<strong>异常处理机制</strong>上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</p></li></ul><h2 id="表级锁" tabindex="-1">表级锁 <a class="header-anchor" href="#表级锁" aria-label="Permalink to &quot;表级锁&quot;">​</a></h2><p>主要分为两种：<strong>表锁</strong>，<strong>元数据锁（meta data lock，MDL)</strong></p><h3 id="表锁" tabindex="-1">表锁 <a class="header-anchor" href="#表锁" aria-label="Permalink to &quot;表锁&quot;">​</a></h3><p><strong>语法是 lock tables … read/write。</strong></p><ul><li><p>与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。</p></li><li><p>lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象</p></li><li><p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。</p></li></ul><h3 id="mdl" tabindex="-1">MDL <a class="header-anchor" href="#mdl" aria-label="Permalink to &quot;MDL&quot;">​</a></h3><p>MDL不需要显式使用，在访问一个表的时候会被自动加上</p><ul><li><p>作用是保证读写的正确性</p></li><li><p>当对一个表做增删改查操作的时候，加MDL<strong>读锁</strong>；当对表做结构变更操作的时候，加MDL<strong>写锁</strong></p></li><li><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查</p></li><li><p>读写锁之间、写锁之间是<strong>互斥</strong>的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行</p></li></ul><h3 id="如何安全地给小标加字段" tabindex="-1">如何安全地给小标加字段 <a class="header-anchor" href="#如何安全地给小标加字段" aria-label="Permalink to &quot;如何安全地给小标加字段&quot;">​</a></h3><ul><li><p>首先要解决长事务，事务不提交，就会一直占着MDL锁</p></li><li><p>MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务</p></li><li><p>如果要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务</p></li></ul><p>若变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，需要加个字段，该如何做？</p><ul><li><p>比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃</p></li><li><p>开发人员或者DBA再通过重试命令重复这个过程</p></li></ul>',18),i=[r];function n(s,p,d,h,c,u){return t(),a("div",null,i)}const b=l(o,[["render",n]]);export{_ as __pageData,b as default};
