import{_ as i,c as s,o as n,a1 as a}from"./chunks/framework.DCKU21so.js";const l="/assets/1.XbVUoCNO.jpeg",t="/assets/2.DPqXoJjk.png",y=JSON.parse('{"title":"为什么 MySQL 会“抖”一下","description":"","frontmatter":{},"headers":[],"relativePath":"DATABASE/MySQL/chap11.md","filePath":"DATABASE/MySQL/chap11.md"}'),o={name:"DATABASE/MySQL/chap11.md"},p=a('<h1 id="为什么-mysql-会-抖-一下" tabindex="-1">为什么 MySQL 会“抖”一下 <a class="header-anchor" href="#为什么-mysql-会-抖-一下" aria-label="Permalink to &quot;为什么 MySQL 会“抖”一下&quot;">​</a></h1><p>现象：一条 SQL 语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。</p><h2 id="sql-语句为什么会变慢" tabindex="-1">SQL 语句为什么会变慢 <a class="header-anchor" href="#sql-语句为什么会变慢" aria-label="Permalink to &quot;SQL 语句为什么会变慢&quot;">​</a></h2><p>InnoDB 在处理更新语句的时候，只做了写日志这一个磁盘操作，这个日志叫作 redo log（重做日志）。在更新内存写完 redo log 后，就返回给客户端，本次更新成功。</p><p>而当系统需要找时间把内存里的数据写入磁盘，这个过程称为 flush。</p><ul><li>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“<strong>脏页</strong>”。</li><li>内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“<strong>干净页</strong>”。</li></ul><p>用“孔乙己赊账”的过程来说明 flush 的流程：</p><p><img src="'+l+`" alt="image"></p><p>因此，平时执行很快的更新操作，其实就是在写内存和日志，而 MySQL 偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。</p><h3 id="引发-flush-过程的情况" tabindex="-1">引发 flush 过程的情况 <a class="header-anchor" href="#引发-flush-过程的情况" aria-label="Permalink to &quot;引发 flush 过程的情况&quot;">​</a></h3><ol><li><p>第一种场景是 redo log 写满了，这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写。</p></li><li><p>第二种场景是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。<strong>如果淘汰的是“脏页”，就要先将脏页写到磁盘</strong>。如果刷脏页一定会写到磁盘，就保证了每个数据页有两种状态：</p></li></ol><ul><li>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</li><li>一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。 因此，这样的方式效率更高，而不用直接把内存淘汰掉</li></ul><ol start="3"><li><p>第三种场景是 MySQL 认为系统“空闲”的时候，来进行 flush 操作，需要合理安排时间来进行 flush 操作。</p></li><li><p>第四种场景是 MySQL 正常关闭的情况。此时，<strong>MySQL 会把内存的脏页都 flush 到磁盘上</strong>，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p></li></ol><p><strong>前两种场景对性能的影响：</strong></p><ol><li><p>“redo log 写满了，要 flush 脏页”，这种情况是 InnoDB 要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为 0。</p></li><li><p>“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。<strong>InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态</strong>：</p></li></ol><ul><li>第一种是，还没有使用的；</li><li>第二种是，使用了并且是干净页</li><li>第三种是，使用了并且是脏页</li></ul><p>InnoDB 的策略是<strong>尽量使用内存</strong>，因此对于一个长时间运行的库来说，未被使用的页面很少。</p><p>那么具体的做法是：而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把<strong>最久不使用的数据页</strong>从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p><p>刷脏页会出现两种影响性能的情况：</p><ol><li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li><li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。</li></ol><p>因此，InnoDB 需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p><h2 id="innodb-刷脏页的控制策略" tabindex="-1">InnoDB 刷脏页的控制策略 <a class="header-anchor" href="#innodb-刷脏页的控制策略" aria-label="Permalink to &quot;InnoDB 刷脏页的控制策略&quot;">​</a></h2><p>首先，需要通过参数 innodb_io_capacity 来告诉 InnoDB 主机的 IO 能力，该参数可设置为磁盘的 IOPS。</p><p>如果没能正确设置 innodb_io_capacity 参数会导致 InnoDB 认为系统能力差，从而造成刷脏页刷的慢，甚至比脏页生成的速度还慢，这样就造成了脏页累积，影响了查询和更新性能。</p><p>另外，磁盘能力不能只用来刷脏页，还需要服务用户请求，所以还需要控制全力刷脏页的比例</p><h3 id="innodb-如何设计策略来控制引擎刷脏页的速度。" tabindex="-1">InnoDB 如何设计策略来控制引擎刷脏页的速度。 <a class="header-anchor" href="#innodb-如何设计策略来控制引擎刷脏页的速度。" aria-label="Permalink to &quot;InnoDB 如何设计策略来控制引擎刷脏页的速度。&quot;">​</a></h3><p>InnoDB 的刷盘速度主要考虑两个因素：一个是脏页比例，一个是 redo log 写盘速度。InnoDB 会根据这两个因素先单独算出两个数字。</p><ol><li>参数 innodb_max_dirty_pages_pct 是脏页比例上限，默认值是 75%。InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字，计算该数字的伪代码如下：</li></ol><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">F1(M)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> M</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">innodb_max_dirty_pages_pct </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">M</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">innodb_max_dirty_pages_pct;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>而 InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，我们假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。F2(N) 算法比较复杂，只要知道 N 越大，算出来的值越大就好了。</p><ol start="2"><li>再根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，<mark>之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度。</mark></li></ol><p>具体流程如下所示：</p><p><img src="`+t+'" alt="image"></p><p>因此，为了避免 MySQL&quot;抖&quot;的情况，应合理地设置 innodb_io_capacity 的值，<strong>并且平时要多关注脏页比例，不要让它经常接近 75%。</strong></p><h3 id="innodb-flush-操作的-连坐-机制" tabindex="-1">InnoDB flush 操作的“连坐”机制 <a class="header-anchor" href="#innodb-flush-操作的-连坐-机制" aria-label="Permalink to &quot;InnoDB flush 操作的“连坐”机制&quot;">​</a></h3><ul><li>MySQL 中存在一个“连坐”机制：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</li><li>在 InnoDB 中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为 1 的时候会有上述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。</li><li>找“邻居”这个优化在<strong>机械硬盘</strong>时代是很有意义的，可以减少很多随机 IO。机械硬盘的随机 IOPS 一般只有几百，相同的逻辑操作减少随机 IO 就意味着系统性能的大幅度提升。</li><li>对于 SSD 这类 IOPS 比较高的设备，建议将 innodb_flush_neighbors 的值设置成 0，<mark>因为 IOPS 往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少 SQL 语句响应时间。</mark></li></ul>',36),e=[p];function h(r,d,k,c,g,_){return n(),s("div",null,e)}const E=i(o,[["render",h]]);export{y as __pageData,E as default};
