import{_ as s,c as i,o as a,a1 as l}from"./chunks/framework.BzbwRryB.js";const h="/docs-lwg.github.io/assets/1.BJRmsNkP.png",t="/docs-lwg.github.io/assets/2.BGlLHGJw.png",n="/docs-lwg.github.io/assets/3.3299rB6y.png",b=JSON.parse('{"title":"MySQL为什么会选错索引？","description":"","frontmatter":{},"headers":[],"relativePath":"DATABASE/MySQL/chap09.md","filePath":"DATABASE/MySQL/chap09.md"}'),p={name:"DATABASE/MySQL/chap09.md"},e=l('<h1 id="mysql为什么会选错索引" tabindex="-1">MySQL为什么会选错索引？ <a class="header-anchor" href="#mysql为什么会选错索引" aria-label="Permalink to &quot;MySQL为什么会选错索引？&quot;">​</a></h1><p>举例说明： 假设表里有a、b两个字段，并分别建上索引：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> `</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">` (</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  `id`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  `a`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">DEFAULT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  `b`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">DEFAULT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  PRIMARY KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`id`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  KEY</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `a`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`a`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  KEY</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `b`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`b`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ENGINE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">InnoDB；</span></span></code></pre></div><p>现往表t中插入10万行记录，取值按整数递增。而当做如下操作：</p><p><img src="'+h+'" alt="image"></p><ul><li>session A 开启了一个事务；随后，session B 把数据都删除后，又调用了 idata 这个存储过程，插入了 10 万行数据。</li><li>session B 再进行查询操作： select * from t where a between 10000 and 20000</li></ul><p>结果中，session B在执行查询操作时没有选择索引a，导致了更长的执行时间，共扫描了10万行。</p><h2 id="优化器的逻辑" tabindex="-1">优化器的逻辑 <a class="header-anchor" href="#优化器的逻辑" aria-label="Permalink to &quot;优化器的逻辑&quot;">​</a></h2><p>优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。</p><ul><li>在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。</li><li>扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</li></ul><h3 id="扫描行数的判断" tabindex="-1">扫描行数的判断 <a class="header-anchor" href="#扫描行数的判断" aria-label="Permalink to &quot;扫描行数的判断&quot;">​</a></h3><p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。</p><ul><li>而统计信息就是索引的<strong>区分度</strong>，一个索引上不同的值越多，这个索引的区分度就越好。</li><li>而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</li></ul><h3 id="如何得到索引的基数" tabindex="-1">如何得到索引的基数 <a class="header-anchor" href="#如何得到索引的基数" aria-label="Permalink to &quot;如何得到索引的基数&quot;">​</a></h3><p>采样统计的<strong>动机</strong>：如果把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了</p><ul><li>采样统计时，InnoDB 默认会选择 N 个数据页，<strong>统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数</strong>。</li><li>当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。</li></ul><p>MySQL中，有两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent 的值来选择：</p><ul><li>设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。</li><li>设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。</li></ul><p>优化器不全是根据索引统计值来进行判断，还需要判断执行这个语句本身需要扫描多少行。</p><p><img src="'+t+'" alt="image"></p><p>以上结果为优化器预估两个语句的扫描行数结果：(rows 字段表示的是预计扫描行数)</p><ul><li>Q1结果还是符合预期的，rows 的值是 104620；</li><li>Q2 的 rows 值是 37116，偏差就大了</li></ul><p>优化器选择执行扫描行数为100000的执行计划的原因：</p><ul><li>如果使用索引 a，每次从索引 a 上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。</li><li>如果选择扫描 10 万行，是直接在主键索引上扫描的，没有额外的代价。</li><li>优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。</li></ul><p>因此，MySQL选错索引归根结底是没能准确地判断出扫描行数</p><p>而在实践中，可用 analyze table t 命令来重新统计索引信息：</p><p><img src="'+n+'" alt="image"></p><p>事实上，因为优化器不只是根据扫描行数来进行判断，所以可通过analyze命令来解决很多问题。</p><h2 id="索引选择异常和处理" tabindex="-1">索引选择异常和处理 <a class="header-anchor" href="#索引选择异常和处理" aria-label="Permalink to &quot;索引选择异常和处理&quot;">​</a></h2><h3 id="第一种方法-采用force-index-强行选择一个索引" tabindex="-1">第一种方法：采用force index 强行选择一个索引 <a class="header-anchor" href="#第一种方法-采用force-index-强行选择一个索引" aria-label="Permalink to &quot;第一种方法：采用force index 强行选择一个索引&quot;">​</a></h3><p>MySQL 会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。<strong>如果 force index 指定的索引在候选索引列表中，就直接选择这个索引</strong>，不再评估其他索引的执行代价。</p><p>但这种方式存在以下问题：</p><ul><li>如果索引改了名字，则相应的语句也得修改</li><li>如果以后迁移到别的数据库的话，这个语法还可能会不兼容。</li><li>最主要的问题是变更的及时性：出现问题时加上force index来进行修改，但是等到下次测试时就还需要进行修改，这种方式对于生产系统来说不够敏捷。</li></ul><h3 id="第二种方法-考虑修改语句-引导mysql使用我们期望的索引" tabindex="-1">第二种方法：考虑修改语句，引导MySQL使用我们期望的索引 <a class="header-anchor" href="#第二种方法-考虑修改语句-引导mysql使用我们期望的索引" aria-label="Permalink to &quot;第二种方法：考虑修改语句，引导MySQL使用我们期望的索引&quot;">​</a></h3><p>对于以下例子来说：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> explain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">between</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">between</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">order by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">limit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>如果将order by b limit 1” 改成 “order by b,a limit 1”，效果会得到提升。</p><ul><li>之前优化器选择使用索引 b，是因为它认为使用索引 b 可以避免排序（b 本身是索引，已经是有序的了，如果选择索引 b 的话，不需要再做排序，只需要遍历），所以即使扫描行数多，也判定为代价更小。</li><li>现在 order by b,a 这种写法，要求按照 b,a 排序，就意味着<strong>使用这两个索引都需要排序</strong>。<mark>因此，扫描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描 1000 行的索引 a。</mark></li></ul><h3 id="第三种方法-在有些场景下-我们可以新建一个更合适的索引-来提供给优化器做选择-或删掉误用的索引。" tabindex="-1">第三种方法：在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。 <a class="header-anchor" href="#第三种方法-在有些场景下-我们可以新建一个更合适的索引-来提供给优化器做选择-或删掉误用的索引。" aria-label="Permalink to &quot;第三种方法：在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。&quot;">​</a></h3>',39),k=[e];function r(d,E,o,g,y,c){return a(),i("div",null,k)}const u=s(p,[["render",r]]);export{b as __pageData,u as default};
