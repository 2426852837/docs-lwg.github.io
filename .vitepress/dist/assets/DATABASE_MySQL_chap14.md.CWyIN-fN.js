import{_ as i,a as s,b as a}from"./chunks/3.UCZLrRc6.js";import{_ as l,c as n,o as e,a1 as h}from"./chunks/framework.BzbwRryB.js";const A=JSON.parse('{"title":"日志和索引相关问题","description":"","frontmatter":{},"headers":[],"relativePath":"DATABASE/MySQL/chap14.md","filePath":"DATABASE/MySQL/chap14.md"}'),t={name:"DATABASE/MySQL/chap14.md"},r=h('<h1 id="日志和索引相关问题" tabindex="-1">日志和索引相关问题 <a class="header-anchor" href="#日志和索引相关问题" aria-label="Permalink to &quot;日志和索引相关问题&quot;">​</a></h1><h2 id="两阶段提交的不同瞬间-mysql-如果发生异常重启-是怎么保证数据完整性的" tabindex="-1">两阶段提交的不同瞬间，MySQL 如果发生异常重启，是怎么保证数据完整性的？ <a class="header-anchor" href="#两阶段提交的不同瞬间-mysql-如果发生异常重启-是怎么保证数据完整性的" aria-label="Permalink to &quot;两阶段提交的不同瞬间，MySQL 如果发生异常重启，是怎么保证数据完整性的？&quot;">​</a></h2><p><img src="'+i+'" alt="image"></p><ul><li>如果图中 A 时刻的地方（写入 redo log 处于 prepare 阶段之后、写 binlog 之前），发生了崩溃（crash），由于此时 binlog 还没写，redo log 也还没提交，所以崩溃恢复的时候，这个<strong>事务会回滚</strong>。</li><li>如果时刻 B（ binlog 写完，redo log 还没 commit 前）发生 crash，MySQL 的处理： <ol><li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；</li><li>如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整： a. 如果是，则提交事务； b. 否则，回滚事务。</li></ol></li></ul><h3 id="mysql-如何知道-binlog-是完整的" tabindex="-1">MySQL 如何知道 binlog 是完整的 <a class="header-anchor" href="#mysql-如何知道-binlog-是完整的" aria-label="Permalink to &quot;MySQL 如何知道 binlog 是完整的&quot;">​</a></h3><p>一个事务的 binlog 是有完整格式的：</p><ul><li>statement 格式的 binlog，最后会有 COMMIT；</li><li>row 格式的 binlog，最后会有一个 XID event。</li><li>另外，在 MySQL 5.6.2 版本以后，还引入了 binlog-checksum 参数，用来验证 binlog 内容的正确性。</li><li>对于 binlog 日志由于磁盘原因，可能会在日志中间出错的情况，MySQL 可以通过校验 checksum 的结果来发现。</li></ul><h3 id="redo-log-和-binlog-是怎么关联起来的" tabindex="-1">redo log 和 binlog 是怎么关联起来的? <a class="header-anchor" href="#redo-log-和-binlog-是怎么关联起来的" aria-label="Permalink to &quot;redo log 和 binlog 是怎么关联起来的?&quot;">​</a></h3><p>它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：</p><ul><li>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</li><li>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</li></ul><h3 id="处于-prepare-阶段的-redo-log-加上完整-binlog-重启就能恢复-mysql-为什么要这么设计" tabindex="-1">处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计? <a class="header-anchor" href="#处于-prepare-阶段的-redo-log-加上完整-binlog-重启就能恢复-mysql-为什么要这么设计" aria-label="Permalink to &quot;处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?&quot;">​</a></h3><p>在时刻 B，也就是 binlog 写完以后 MySQL 发生崩溃，这时候 binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p><h3 id="如果这样的话-为什么还要两阶段提交呢-干脆先-redo-log-写完-再写-binlog。崩溃恢复的时候-必须得两个日志都完整才可以。是不是一样的逻辑" tabindex="-1">如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？ <a class="header-anchor" href="#如果这样的话-为什么还要两阶段提交呢-干脆先-redo-log-写完-再写-binlog。崩溃恢复的时候-必须得两个日志都完整才可以。是不是一样的逻辑" aria-label="Permalink to &quot;如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？&quot;">​</a></h3><ul><li>对于 InnoDB 引擎来说，如果 redo log 提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。</li><li>如果 redo log 直接提交，然后 binlog 写入的时候失败，InnoDB 又回滚不了，数据和 binlog 日志又不一致了。</li><li>两阶段提交就是<strong>为了给所有人一个机会，当每个人都说“我 ok”的时候，再一起提交</strong>。</li></ul><h3 id="只用-binlog-来支持崩溃恢复-又能支持归档-是否可行" tabindex="-1">只用 binlog 来支持崩溃恢复，又能支持归档，是否可行？ <a class="header-anchor" href="#只用-binlog-来支持崩溃恢复-又能支持归档-是否可行" aria-label="Permalink to &quot;只用 binlog 来支持崩溃恢复，又能支持归档，是否可行？&quot;">​</a></h3><p>binlog 不支持崩溃恢复。如下是只用 binlog 来实现崩溃恢复的示意图：</p><p><img src="'+s+'" alt="image"></p><p>在图中 crash 的位置，即 binlog2 写完了，但是整个事务还没有 commit 的时候，MySQL 发生了 crash。</p><ul><li>重启后，引擎内部事务 2 会回滚，然后应用 binlog2 可以补回来；</li><li>但是对于事务 1 来说，系统已经认为提交完成了，不会再应用一次 binlog1。</li><li>由于 InnoDB 引擎使用的是 WAL 技术，要依赖于日志来恢复数据页。因此，事务 1 也是可能丢失了的，而且是数据页级的丢失。此时，binlog 里面并没有记录数据页的更新细节，是补不回来的。</li></ul><h3 id="若只用-redo-log-不要-binlog" tabindex="-1">若只用 redo log，不要 binlog? <a class="header-anchor" href="#若只用-redo-log-不要-binlog" aria-label="Permalink to &quot;若只用 redo log，不要 binlog?&quot;">​</a></h3><p>binlog 有 redo log 无法替代的功能</p><ul><li>归档：redo log 是循环写，<strong>写到末尾是要回到开头继续写的</strong>。这样历史日志没法保留，redo log 也就起不到归档的作用。</li><li>MySQL 系统依赖于 binlog：binlog 作为 MySQL 一开始就有的功能，被用在了很多地方。其中，MySQL 系统高可用的基础，就是 binlog 复制。</li></ul><h3 id="正常运行中的实例-数据写入后的最终落盘-是从-redo-log-更新过来的还是从-buffer-pool-更新过来的呢" tabindex="-1">正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？ <a class="header-anchor" href="#正常运行中的实例-数据写入后的最终落盘-是从-redo-log-更新过来的还是从-buffer-pool-更新过来的呢" aria-label="Permalink to &quot;正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？&quot;">​</a></h3><p>实际上，redo log 并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由 redo log 更新过去”的情况。</p><ul><li>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与 redo log 毫无关系。</li><li>在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</li></ul><h3 id="redo-log-buffer-是什么-是先修改内存-还是先写-redo-log-文件" tabindex="-1">redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？ <a class="header-anchor" href="#redo-log-buffer-是什么-是先修改内存-还是先写-redo-log-文件" aria-label="Permalink to &quot;redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？&quot;">​</a></h3><p>redo log buffer 是在内存中，用于先存放 redo 日志的。</p><ul><li>真正把日志写到 redo log 文件（文件名是 ib_logfile+ 数字），是在<strong>执行 commit 语句</strong>的时候做的。</li><li>单独执行一个更新语句的时候，InnoDB 会自己启动一个事务，在语句执行完成的时候提交。</li></ul><h2 id="业务设计问题" tabindex="-1">业务设计问题 <a class="header-anchor" href="#业务设计问题" aria-label="Permalink to &quot;业务设计问题&quot;">​</a></h2><p>有关索引的业务：（问题：并发场景下，同时有两个人，设置为关注对方，就可能导致无法成功加为朋友关系。）</p><p><img src="'+a+`" alt="image"></p><ul><li>由于一开始 A 和 B 之间没有关注关系，所以两个事务里面的 select 语句查出来的结果都是空。</li><li>因此，session 1 的逻辑就是“既然 B 没有关注 A，那就只插入一个单向关注关系”。session 2 也同样是这个逻辑。所以出现 bug</li></ul><h3 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h3><p>首先给“like”表增加一个字段，比如叫作 relation_ship，并设为整型，取值 1、2、3。 - 值是 1 的时候，表示 user_id 关注 liker_id; - 值是 2 的时候，表示 liker_id 关注 user_id; - 值是 3 的时候，表示互相关注。</p><p>当 A 关注 B 时，逻辑为：</p><ol><li>比较 A 和 B 的大小，如果 A &lt; B，则执行：</li></ol><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> begin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 启动事务 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">insert into</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`like\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user_id, liker_id, relation_ship) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(A, B, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> duplicate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> relation_ship</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">relation_ship | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> relation_ship </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`like\`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> liker_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">B;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 代码中判断返回的 relation_ship，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  如果是 1，事务结束，执行 commit</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  如果是 3，则执行下面这两个语句：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">insert ignore into</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> friend(friend_1_id, friend_2_id) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(A,B);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">commit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><ol start="2"><li>如果 A&gt;B，则执行:</li></ol><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> begin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 启动事务 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">insert into</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`like\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user_id, liker_id, relation_ship) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(B, A, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> duplicate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> relation_ship</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">relation_ship | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> relation_ship </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`like\`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">B </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> liker_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 代码中判断返回的 relation_ship，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  如果是 2，事务结束，执行 commit</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  如果是 3，则执行下面这两个语句：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">*/</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">insert ignore into</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> friend(friend_1_id, friend_2_id) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(B,A);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">commit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>这样的设计中，like”表里的数据保证 user_id &lt; liker_id，这样不论是 A 关注 B，还是 B 关注 A，在操作“like”表的时候，<mark>如果反向的关系已经存在，就会出现行锁冲突。</mark></p><ul><li>insert … on duplicate 语句: 确保了在事务内部，执行了这个 SQL 语句后，就强行占住了这个行锁，之后的 select 判断 relation_ship 这个逻辑时就确保了是在行锁保护下的读操作。</li><li>操作符 “|” 是按位或，连同最后一句 insert 语句里的 ignore，是为了保证重复调用时的幂等性。</li></ul>`,41),p=[r];function o(k,d,g,E,y,c){return e(),n("div",null,p)}const m=l(t,[["render",o]]);export{A as __pageData,m as default};
