import{_ as i,c as s,o as a,a1 as h}from"./chunks/framework.BzbwRryB.js";const l="/docs-lwg.github.io/assets/1.D3-HR8Kq.png",t="/docs-lwg.github.io/assets/2.Dyc40PSM.png",u=JSON.parse('{"title":"如何给字符串加索引？","description":"","frontmatter":{},"headers":[],"relativePath":"DATABASE/MySQL/chap10.md","filePath":"DATABASE/MySQL/chap10.md"}'),e={name:"DATABASE/MySQL/chap10.md"},n=h(`<h1 id="如何给字符串加索引" tabindex="-1">如何给字符串加索引？ <a class="header-anchor" href="#如何给字符串加索引" aria-label="Permalink to &quot;如何给字符串加索引？&quot;">​</a></h1><p>在实际场景中（例如在邮箱上建立索引），MySQL可以通过前缀索引来在字符串上加索引。默认地，如果创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</p><h2 id="举例说明前缀索引的优势" tabindex="-1">举例说明前缀索引的优势 <a class="header-anchor" href="#举例说明前缀索引的优势" aria-label="Permalink to &quot;举例说明前缀索引的优势&quot;">​</a></h2><p>假设存在语句：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> alter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> table</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SUser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index1(email);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">或</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> alter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> table</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SUser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index2(email(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><p>第一个语句创建的 index1 索引里面，包含了每个记录的整个字符串；而第二个语句创建的 index2 索引里面，对于每个记录都是只取前 6 个字节。那么这两个索引的示意图如下所示：</p><p><img src="`+l+'" alt="image"></p><p><img src="'+t+'" alt="image"></p><p>执行以下语句后，索引是如何执行的：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,email </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SUser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> email</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;zhangssxyz@xxx.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p><strong>如果是 index1</strong>（即 email 整个字符串的索引结构），执行顺序为：</p><ol><li>从 index1 索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得 ID2 的值；</li><li>到主键上查到主键值是 ID2 的行，判断 email 的值是正确的，将这行记录加入结果集；</li><li>取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足 email=&#39;zhangssxyz@xxx.com’的条件了，循环结束。</li></ol><p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行</p><p><strong>如果是 index2</strong>（即 email(6) 索引结构），执行顺序为：</p><ol><li>从 index2 索引树找到满足索引值是&#39;zhangs&#39;的记录，找到的第一个是 ID1；</li><li>到主键上查到主键值是 ID1 的行，判断出 email 的值不是’zhangssxyz@xxx.com’，这行记录丢弃；</li><li>取 index2 上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出 ID2，再到 ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li><li>重复上一步，直到在 idxe2 上取到的值不是’zhangs’时，循环结束。</li></ol><p>在这个过程中，要回主键索引取 4 次数据，也就是扫描了 4 行。</p><p><strong>结论</strong>：</p><ul><li>使用前缀索引可能会导致查询语句读数据的次数变多</li><li><strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本</strong>。</li></ul><h3 id="如何确定前缀的长度" tabindex="-1">如何确定前缀的长度？ <a class="header-anchor" href="#如何确定前缀的长度" aria-label="Permalink to &quot;如何确定前缀的长度？&quot;">​</a></h3><ul><li>实际上需要关注区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。</li><li>可通过统计索引上有多少个不同的值来判断要使用多长的前缀。</li></ul><h2 id="前缀索引对覆盖索引的影响" tabindex="-1">前缀索引对覆盖索引的影响 <a class="header-anchor" href="#前缀索引对覆盖索引的影响" aria-label="Permalink to &quot;前缀索引对覆盖索引的影响&quot;">​</a></h2><p>对于以下SQL语句：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id,email </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SUser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> email</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;zhangssxyz@xxx.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><ul><li>若采用index1（即 email 整个字符串的索引结构）的话，可以利用覆盖索引，从 index1 查到结果后直接就返回了，不需要回到 ID 索引再去查一次。</li><li>如果使用 index2（即 email(6) 索引结构）的话，就不得不回到 ID 索引再去判断 email 字段的值。</li><li>即使将 index2 的定义修改为 email(18) 的前缀索引，但 InnoDB 还是要回到 id 索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</li></ul><h2 id="其他方式" tabindex="-1">其他方式 <a class="header-anchor" href="#其他方式" aria-label="Permalink to &quot;其他方式&quot;">​</a></h2><p>对于区分度不够好的情况，就无法使用前缀索引来为字符串添加索引。（例如为维护一个市的公民信息系统）</p><p>此外，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。</p><h3 id="第一种方式-使用倒序存储" tabindex="-1">第一种方式：使用倒序存储 <a class="header-anchor" href="#第一种方式-使用倒序存储" aria-label="Permalink to &quot;第一种方式：使用倒序存储&quot;">​</a></h3><p>可以将身份证号以倒序来存，由于身份证号的最后 6 位没有地址码这样的重复逻辑，所以最后这 6 位很可能就提供了足够的区分度。当然了，实践中你不要忘记使用 count(distinct) 方法去做个验证。</p><h3 id="第二种方式-使用hash字段" tabindex="-1">第二种方式：使用hash字段 <a class="header-anchor" href="#第二种方式-使用hash字段" aria-label="Permalink to &quot;第二种方式：使用hash字段&quot;">​</a></h3><p>可以在表上再创建一个整数字段，<strong>来保存身份证的校验码</strong>，同时在这个字段上创建索引。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> alter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> table</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id_card_crc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unsigned, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id_card_crc);</span></span></code></pre></div><p>然后每次插入新记录的时候，都同时用 crc32() 这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过 crc32() 函数得到的结果可能是相同的，所以你的查询语句 where 部分要判断 id_card 的值是否精确相同。即，</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> field_list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id_card_crc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">crc32(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;input_id_card_string&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id_card</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;input_id_card_string&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="倒序存储和使用-hash-字段这两种方法的异同点" tabindex="-1">倒序存储和使用 hash 字段这两种方法的异同点 <a class="header-anchor" href="#倒序存储和使用-hash-字段这两种方法的异同点" aria-label="Permalink to &quot;倒序存储和使用 hash 字段这两种方法的异同点&quot;">​</a></h3><p>相同点：都不支持范围查询。</p><ul><li>倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。</li><li>同样地，hash 字段的方式也只能支持等值查询。</li></ul><p>区别：</p><ul><li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。</li><li>在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。</li><li>从查询效率上看，<strong>使用 hash 字段方式的查询性能相对更稳定一些</strong>。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li></ul>',39),p=[n];function k(d,r,g,E,o,c){return a(),s("div",null,p)}const m=i(e,[["render",k]]);export{u as __pageData,m as default};
