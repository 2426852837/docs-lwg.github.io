import{_ as s,c as i,o as a,a1 as h}from"./chunks/framework.BzbwRryB.js";const l="/docs-lwg.github.io/assets/1.SIeDsPjm.png",t="/docs-lwg.github.io/assets/2.Dx9V7cXN.png",n="/docs-lwg.github.io/assets/3.BVhr-yrU.png",p="/docs-lwg.github.io/assets/4.Dhc0ojws.png",k="/docs-lwg.github.io/assets/5.CmraEmxW.png",e="/docs-lwg.github.io/assets/6.B4H9CK8T.png",d="/docs-lwg.github.io/assets/7.DJ57Y6Ll.png",b=JSON.parse('{"title":"为什么查询一行的语句，执行也会很慢","description":"","frontmatter":{},"headers":[],"relativePath":"DATABASE/MySQL/chap18.md","filePath":"DATABASE/MySQL/chap18.md"}'),r={name:"DATABASE/MySQL/chap18.md"},E=h(`<h1 id="为什么查询一行的语句-执行也会很慢" tabindex="-1">为什么查询一行的语句，执行也会很慢 <a class="header-anchor" href="#为什么查询一行的语句-执行也会很慢" aria-label="Permalink to &quot;为什么查询一行的语句，执行也会很慢&quot;">​</a></h1><p>举例说明：表 t 有两个字段<code>id</code>和<code>c</code>，相应的 SQL 语句如下所示：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`t\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`id\`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`c\`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">DEFAULT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> PRIMARY KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`id\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ENGINE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">InnoDB;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">//</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 插入语句</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">delimiter ;;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">create</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> procedure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> idata()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">begin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> declare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) do</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> insert into</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i,i);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> end</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">delimiter ;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> idata();</span></span></code></pre></div><h2 id="查询长时间不返回" tabindex="-1">查询长时间不返回 <a class="header-anchor" href="#查询长时间不返回" aria-label="Permalink to &quot;查询长时间不返回&quot;">​</a></h2><p>这种情况下，首先执行 show processlist 命令，看看当前语句处于什么状态。</p><h3 id="等-mdl-锁" tabindex="-1">等 MDL 锁 <a class="header-anchor" href="#等-mdl-锁" aria-label="Permalink to &quot;等 MDL 锁&quot;">​</a></h3><p><img src="`+l+'" alt="image"></p><p>以上是 show processlist 命令查看 Waiting for table metadata lock 的示意图。</p><p>此时表示：<strong>现在有一个线程正在表 t 上请求或者持有 MDL 写锁，把 select 语句堵住了</strong>。</p><p>处理方式：找到哪个线程持有 MDL 写锁，并将其 kill。</p><p>可通过查询<code>sys.schema_table_lock_waits</code> 这张表， 可以直接找出造成阻塞的 process id，把这个连接用 kill 命令断开即可：</p><p><img src="'+t+`" alt="image"></p><h3 id="等-flush" tabindex="-1">等 flush <a class="header-anchor" href="#等-flush" aria-label="Permalink to &quot;等 flush&quot;">​</a></h3><p>当线程出现 Waiting for table flush，表示现在有一个线程正要对表 t 做 flush 操作。</p><p>对于 MySQL 来说，对表进行 flush 操作的用法 有两种：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flush tables t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">with</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lock;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flush tables </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">with</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lock;</span></span></code></pre></div><p>如果指定表 t 的话，代表的是只关闭表 t；如果没有指定具体的表名，则表示关闭 MySQL 里所有打开的表。（这两个语句执行很快，除非被其他线程阻塞了）</p><p>因此，出现这种情况的原因是：有一个 flush tables 命令被别的语句堵住了，然后它又堵住了我们的 select 语句。示意图如下所示：</p><p><img src="`+n+'" alt="image"></p><h3 id="等行锁" tabindex="-1">等行锁 <a class="header-anchor" href="#等行锁" aria-label="Permalink to &quot;等行锁&quot;">​</a></h3><p>执行如下语句：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> share mode;</span></span></code></pre></div><p>由于访问 id=1 这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，select 语句就会被堵住。</p><p>这种情况的复现步骤如下：</p><p><img src="'+p+'" alt="image"></p><p>因此，需要查找出哪个线程占有写锁，以下是通过 sys.innodb_lock_waits 表查询的结果：</p><p><img src="'+k+`" alt="image"></p><p>因此，可以看出是 4 号线程占有写锁，因此需要 KILL 4。</p><ul><li><code>KILL QUERY 4</code> 表示停止 4 号线程当前正在执行的语句，而这个方法其实是没有用的。因为占有行锁的是 update 语句，这个语句已经是之前执行完成了的，现在执行 KILL QUERY，无法让这个事务去掉 id=1 上的行锁。</li><li><code>KILL 4</code> 才有效，也就是说直接断开这个连接。隐含的逻辑是：连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了 id=1 上的行锁。</li></ul><h2 id="查询慢" tabindex="-1">查询慢 <a class="header-anchor" href="#查询慢" aria-label="Permalink to &quot;查询慢&quot;">​</a></h2><h3 id="字段无索引" tabindex="-1">字段无索引 <a class="header-anchor" href="#字段无索引" aria-label="Permalink to &quot;字段无索引&quot;">​</a></h3><p>执行以下 SQL 语句时：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> limit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>由于字段 c 上没有索引，这个语句只能走 id 主键顺序扫描，因此需要扫描 5 万行。</p><h3 id="一致性读和当前读" tabindex="-1">一致性读和当前读 <a class="header-anchor" href="#一致性读和当前读" aria-label="Permalink to &quot;一致性读和当前读&quot;">​</a></h3><p>分别执行如下 SQL 语句时：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">；</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> share mode</span></span></code></pre></div><ul><li>第一个语句虽然只扫描了 1 行，但其执行时间长达 800 ms</li><li>第二个同样扫描了 1 行，但执行时间是 0.2 ms</li></ul><p>相应的复现步骤如下所示：</p><p><img src="`+e+'" alt="image"></p><p>相应地，session B 执行完 100 万次 update 语句后，查询 id=1 这一行处于什么状态：</p><p><img src="'+d+'" alt="image"></p><ul><li>session B 更新完 100 万次，生成了 100 万个回滚日志 (undo log)。</li><li>带 lock in share mode 的 SQL 语句，是<mark>当前读</mark>，因此会直接读到 1000001 这个结果，所以速度很快</li><li>select * from t where id=1 这个语句，是<mark>一致性读</mark>，因此需要从 1000001 开始，依次执行 undo log，执行了 100 万次以后，才将 1 这个结果返回。</li></ul>',43),g=[E];function o(c,y,F,m,u,A){return a(),i("div",null,g)}const _=s(r,[["render",o]]);export{b as __pageData,_ as default};
