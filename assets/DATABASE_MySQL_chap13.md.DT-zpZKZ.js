import{_ as i,a as l,b as o}from"./chunks/3.BdSQs6w_.js";import{_ as n,c as t,o as a,a1 as e}from"./chunks/framework.DCKU21so.js";const b=JSON.parse('{"title":"count(*)语句","description":"","frontmatter":{},"headers":[],"relativePath":"DATABASE/MySQL/chap13.md","filePath":"DATABASE/MySQL/chap13.md"}'),r={name:"DATABASE/MySQL/chap13.md"},s=e('<h1 id="count-语句" tabindex="-1">count(*)语句 <a class="header-anchor" href="#count-语句" aria-label="Permalink to &quot;count(\\*)语句&quot;">​</a></h1><p>随着系统中记录数越来越多， count(*)语句执行得也会越来越慢。</p><h2 id="count-的实现方式" tabindex="-1">count(*)的实现方式 <a class="header-anchor" href="#count-的实现方式" aria-label="Permalink to &quot;count(\\*)的实现方式&quot;">​</a></h2><p>不同的 MySQL 引擎中，count(*) 有不同的实现方式。</p><p>（此处讨论的是没有过滤条件下的 count(*)操作）</p><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</li><li>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><p><strong>为什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢？</strong></p><p>因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p><ul><li>由于 InnoDB 的事务设计中，默认的隔离级别是可重复读，在代码上就是通过多版本并发控制，也就是 MVCC 来实现的。</li><li><strong>每一行记录都要判断自己是否对这个会话可见</strong>，因此对于 count(*) 请求来说，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</li></ul><p>MySQL 对 count(*)的优化：</p><ul><li>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值，所以普通索引树比主键索引树小很多。</li><li>对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会<strong>找到最小的那棵树来遍历</strong>。</li><li><strong>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</strong></li></ul><p>目前几个统计行数的方法：</p><ul><li>MyISAM 表虽然 count(*) 很快，但是不支持事务；</li><li>show table status 命令虽然返回很快，但是不准确；</li><li>InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。</li></ul><h2 id="用缓存系统保存计数" tabindex="-1">用缓存系统保存计数 <a class="header-anchor" href="#用缓存系统保存计数" aria-label="Permalink to &quot;用缓存系统保存计数&quot;">​</a></h2><p>对于更新很频繁的业务来说，可以使用 Redis 来作为缓存系统，保持这个表的总行数。</p><h3 id="丢失更新问题" tabindex="-1">丢失更新问题 <a class="header-anchor" href="#丢失更新问题" aria-label="Permalink to &quot;丢失更新问题&quot;">​</a></h3><ul><li>缓存系统可能会丢失更新，因为 Redis 的数据不能永久地留在内存里。</li><li>就算将该值定期地持久化存储起来，仍然有可能丢失更新。如果刚刚在数据表中插入了一行，Redis 中保存的值也加了 1，然后 Redis 异常重启了，重启后你要从存储 redis 数据的地方把这个值读回来，而刚刚加 1 的这个计数操作却丢失了。</li><li>相应的解决方法：Redis 异常重启以后，到数据库里面单独执行一次 count(*) 获取真实的行数，再把这个值写回到 Redis 里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本是可以接受的。</li></ul><h3 id="值不精确问题" tabindex="-1">值不精确问题 <a class="header-anchor" href="#值不精确问题" aria-label="Permalink to &quot;值不精确问题&quot;">​</a></h3><p>即使 Redis 正常工作，得到的值还是逻辑上不精确的。</p><p>不精确的定义：</p><ul><li>一种是，查到的 100 行结果里面有最新插入记录，而 Redis 的计数里还没加 1；</li><li>另一种是，查到的 100 行结果里没有最新插入的记录，而 Redis 的计数里已经加了 1。</li></ul><p><img src="'+i+'" alt="image"></p><p>图中，会话 A 是一个插入交易记录的逻辑，往数据表里插入一行 R，然后 Redis 计数加 1；会话 B 就是查询页面显示时需要的数据。</p><ul><li>在 T3 时刻会话 B 来查询的时候，会显示出新插入的 R 这个记录，但是 Redis 的计数还没加 1。出现了数据不一致的情况</li></ul><p>如果将会话 A 的更新顺序调换一下： <img src="'+l+'" alt="image"></p><ul><li>会话 B 在 T3 时刻查询的时候，Redis 计数加了 1 了，但还查不到新插入的 R 这一行，也是数据不一致的情况。</li></ul><p>在并发系统中，是无法精确控制不同线程的执行时刻的，即使 Redis 正常工作，这个计数值还是逻辑上不精确的。</p><h2 id="在数据库保存计数" tabindex="-1">在数据库保存计数 <a class="header-anchor" href="#在数据库保存计数" aria-label="Permalink to &quot;在数据库保存计数&quot;">​</a></h2><p>直接采用单独的一张计数表来保存计数。</p><ol><li><p>解决了崩溃丢失的问题，InnoDB 是支持崩溃恢复不丢数据的。</p></li><li><p>解决计数不精确的问题：采用事务特性来解决</p></li></ol><p><img src="'+o+'" alt="image"></p><ul><li>虽然会话 B 的读操作仍然是在 T3 执行的，但是因为这时候更新事务还没有提交，所以计数值加 1 这个操作对会话 B 还不可见。</li><li>因此，会话 B 看到的结果里， <strong>查计数值和“最近 100 条记录”看到的结果</strong>，逻辑上就是一致的。</li></ul><h2 id="不同的-count-用法-基于-innodb" tabindex="-1">不同的 count 用法（基于 InnoDB） <a class="header-anchor" href="#不同的-count-用法-基于-innodb" aria-label="Permalink to &quot;不同的 count 用法（基于 InnoDB）&quot;">​</a></h2><p>count()是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。</p><p>因此，count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段)，则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p><p>分析性能差别时，存在以下的原则：</p><ol><li>server 层要什么就给什么；</li><li>InnoDB 只给必要的值；</li><li>现在的优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做。</li></ol><ul><li><p>对于 count(主键 id) 来说，<mark>InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层</mark>。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p></li><li><p>对于 count(1) 来说，InnoDB 引擎遍历整张表，<strong>但不取值</strong>。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加；</p></li><li><p>对于 count(字段)来说：</p><ul><li>如果这个“字段”是定义为 NOT NULL 的，那么 InnoDB 引擎会遍历整张表，把每一行的字段值都取出来，返回给 server 层，server 层判断是否有可能为空，按行累加；</li><li>如果这个“字段”定义允许为 NULL，那么 InnoDB 引擎遍历整张表，对于每一行，<strong>先判断这个字段的值是否为 NULL</strong>，不是 Null 再按行累加；</li></ul></li><li><p>对于 count(*) 来说，并不会把全部字段取出来，而是专门做了优化，不取值，<strong>但是不判断是否为空，直接按行累加</strong>。</p></li></ul><p>因此，结论是按照效率排序的话，<mark>count(字段)&lt;count(主键 id)&lt; count(1)≈count(*). </mark></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>把计数放在 Redis 里面，不能够保证计数和 MySQL 表里的数据精确一致的原因，<mark>是这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。</mark></li><li>把计数放在 MySQL 里面，能够保证计数和 MySQL 表里的数据精确一致的原因，<mark>是 MySQL 支持事务，能够拿到精确一致的视图。</mark></li></ul>',41),u=[s];function c(p,d,h,m,_,B){return a(),t("div",null,u)}const D=n(r,[["render",c]]);export{b as __pageData,D as default};
