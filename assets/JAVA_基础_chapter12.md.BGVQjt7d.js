import{_ as s,c as i,o as a,a1 as n}from"./chunks/framework.C70_P7hw.js";const e=""+new URL("chap12_2.BhlaH8j5.png",import.meta.url).href,p=""+new URL("chap12_1.Ba13Ow5k.png",import.meta.url).href,F=JSON.parse('{"title":"异常和断言","description":"","frontmatter":{},"headers":[],"relativePath":"JAVA/基础/chapter12.md","filePath":"JAVA/基础/chapter12.md"}'),l={name:"JAVA/基础/chapter12.md"},h=n('<h1 id="异常和断言" tabindex="-1">异常和断言 <a class="header-anchor" href="#异常和断言" aria-label="Permalink to &quot;异常和断言&quot;">​</a></h1><h2 id="异常" tabindex="-1">异常 <a class="header-anchor" href="#异常" aria-label="Permalink to &quot;异常&quot;">​</a></h2><h3 id="异常类型" tabindex="-1">异常类型 <a class="header-anchor" href="#异常类型" aria-label="Permalink to &quot;异常类型&quot;">​</a></h3><p><img src="'+e+`" alt="异常层次结构"></p><p>异常对象都是派生于<code>java.lang.Throwable</code>类的一个类实例。<code>java.lang.Throwable</code>派生于<code>java.lang.Object</code>类。</p><p><code>Throwable</code>下一层有两个分支：<code>java.lang.Error</code>、<code>java.lang.Exception</code>。</p><p><code>java.lang.Exception</code>这个层次结构又分为几个分支：一个分支派生于<code>java.lang.RuntimeException</code>；一个分支派生于<code>java.io.IOException</code>。这是最重要的两个分支，另外还有几个分支，比如<code>java.lang.ReflectiveOperationException</code>。</p><p>1、==java运行时系统的内部错误和资源耗尽错误属于<code>Error</code>类层次结构==，例如：内存不够<code>java.lang.OutOfMemoryError</code> 等。</p><p>应用程序不应当抛出这个类型的对象，但是如果出现了这样的内部错误，除了通知用户，并尽力妥善地终止程序之外，几乎无能为力。这种情况很少出现。<code>Exception</code>类层次结构是设计java程序时应当重点关注的。</p><p>2、==由编程错误导致的异常属于==<code>RuntimeException</code>==，主要包括：</p><p>（1）错误的强制类型转换<code>java.lang.ClassCastException</code>；</p><p>（2）数组访问越界<code>java.lang.ArrayIndexOutOfBoundsException</code>；</p><p>（3）访问<code>null</code>引用<code>java.lang.NullPointerException</code>；</p><p>......</p><p>3、==如果程序本身没有问题，不是派生于<code>RuntimeException</code>的其他异常都属于<code>IOException</code>==，主要包括：</p><p>（1）设备错误：磁盘故障<code>java.nio.file.FileSystemException</code>（磁盘空间不足、磁盘权限不足等）；</p><p>（2）网络错误：<code>java.net.SocketException</code>（网络连接中断、主机不可达等）；</p><p>（3）数据库错误：<code>java.sql.SQLException</code>（数据库连接中断等）；</p><p>（4）试图打开一个不存在的文件<code>java.io.FileNotFoundException</code>；</p><p>（5）试图超越文件末尾继续读取数据<code>java.io.EOFException</code>；</p><p>......</p><p>4、执行反射操作时引发的异常属于<code>ReflectOperationException</code>，例如：</p><p>试图根据给定的字符串查找<code>Class</code>对象，但这个字符串表示的类不存在 <code>java.lang.ClassNotFoundException</code>。</p><h4 id="检查型异常" tabindex="-1">检查型异常 <a class="header-anchor" href="#检查型异常" aria-label="Permalink to &quot;检查型异常&quot;">​</a></h4><p>java语言规范将派生于<code>Error</code>类和<code>RuntimeException</code>类的所有异常称为==非检查型异常==，所有其他的异常（主要是<code>IOException</code>，当然也包括<code>ReflectOperationException</code>）称为==检查型异常==。</p><p>为什么要这么划分呢？==首先java对<code>Error</code>类异常（错误）无能为力，而<code>RuntimeException</code>类异常一定是程序设计者自己的问题，怎么解决取决于程序设计者而不是java，所以编译器不会检查这些异常的；但是对于其他异常，java能够预料到所有可能出现的异常，因此会检查程序设计者是否为这些异常提供了异常处理器。</p><h4 id="抛出异常" tabindex="-1">抛出异常 <a class="header-anchor" href="#抛出异常" aria-label="Permalink to &quot;抛出异常&quot;">​</a></h4><p>1、如果一个已有的异常类能够满足要求，抛出这个异常就很容易：创建这个异常类的对象然后抛出即可。</p><p>假设使用一个<code>readData</code>方法读取文件。文件首部包含信息<code>Content-length: 1024</code>，即承诺文件长度为<code>1024</code>个字符。但是如果读到<code>700</code>个字符之后文件就结束了，这就属于不正常情况了，应该抛出一个异常。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Scanner in) throws EOFException{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(...){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> in.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasNext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                String message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Content-length:&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;, Received: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EOFException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>2、有时也可能遇到任何标准异常类都无法描述清楚的问题。这种情况下，可以创建自己的异常类。自定义的异常类应该派生于java标准异常类。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FileFormatException</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IOException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FileFormatException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FileFormatException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>==一个方法如果抛出了异常，那么该方法需要在首部声明异常。==</p><h4 id="声明异常" tabindex="-1">声明异常 <a class="header-anchor" href="#声明异常" aria-label="Permalink to &quot;声明异常&quot;">​</a></h4><p>一个方法的首部必须声明所有可能抛出的==检查型异常==。主要包括两种情况：</p><p>1、方法内部抛出了一个异常对象。</p><p>前面说过：==一个方法如果抛出了异常，那么该方法需要在首部声明异常。==</p><p>方法内部使用类似<code>throw e</code>的代码（<code>e</code>是一个==<code>Throwable</code>类或其子类类型==的对象）抛出一个异常对象。方法首部应该声明<code>throws Exception</code>（==<code>Exception</code>类或更具体的异常类型，但是这个类型不应该比抛出的对象实际类型更具体==）。</p><p>2、调用了其他可能抛出检查型异常的方法。</p><p>这里的”调用“不仅仅是直接调用，例如方法<code>A</code>调用<code>B</code>，<code>B</code>调用<code>C</code>，<code>C</code>调用<code>D</code>，那么我们说<code>A</code>、<code>B</code>、<code>C</code>都调用了<code>D</code>。</p><p>（1）异常对象被某个方法抛出后，运行时系统会检查方法的调用栈，看调用该方法的方法是否提供了异常处理器，如果没有，则向上层的方法抛出这个异常（因此调用该方法的方法也必须声明异常）；</p><p>（2）上层的方法还是没有提供异常处理器的话，就向更上层的方法抛出异常对象（因此这个更上层的方法也必须声明异常）；</p><p>（3）直到有某个上层方法提供了异常处理器，这个异常才会被处理（因此之后的上层方法就无需声明异常）；</p><p>（4）否则，如果调用栈的所有方法都没有提供异常处理器的话，程序就会终止。</p><p>==方法首部不需要声明非检查型异常，因为对于这种<code>Error</code>这种异常我们是无能为力的；而对于<code>RuntimeException</code>这种异常，我们应该做的不是声明和处理这个异常，而是修改我们的代码，以避免这个异常。==</p><h4 id="异常声明规则" tabindex="-1">异常声明规则 <a class="header-anchor" href="#异常声明规则" aria-label="Permalink to &quot;异常声明规则&quot;">​</a></h4><p>1、如果编写了一个方法覆盖了超类的方法，而这个超类方法没有抛出异常，那么子类方法就不能抛出异常，而只能捕获异常。</p><p>2、如果超类方法中声明了异常（抛出了异常），那么子类的覆盖方法中不能出现超类方法未列出的异常类型。</p><h3 id="捕获异常" tabindex="-1">捕获异常 <a class="header-anchor" href="#捕获异常" aria-label="Permalink to &quot;捕获异常&quot;">​</a></h3><p>==声明异常是为了抛出异常，捕获异常是为了处理异常，这两者不可兼得，也就是要么抛出异常要么捕获异常。<code>try-catch-finally</code>和<code>try-with-resources</code>语句用于捕获异常。==</p><p>如果发生了某个异常，但没有在任何方法中捕获这个异常，程序就会终止，并在控制台上打印一个消息，其中包括异常的类型和一个堆栈轨迹。</p><h4 id="try-catch-finally语句" tabindex="-1"><code>try-catch-finally</code>语句 <a class="header-anchor" href="#try-catch-finally语句" aria-label="Permalink to &quot;\`try-catch-finally\`语句&quot;">​</a></h4><p>要想捕获一个异常，需要设置<code>try-catch-finally</code>语句块。</p><h5 id="语法规则" tabindex="-1">语法规则 <a class="header-anchor" href="#语法规则" aria-label="Permalink to &quot;语法规则&quot;">​</a></h5><p>1、<code>catch</code>部分</p><p>（1）这部分可以没有。</p><p>（2）这部分可以有多个，以捕获多个类型的异常。</p><p>（3）一个<code>catch</code>块中声明的捕获类型可以使用<code>A | B</code>位运算符表示这个异常的类型可以是<code>A</code>也可以是<code>B</code>。但是函数中不能这么写，必须用重载。</p><p>（4）如果没有任何<code>catch</code>块能够捕获到某个类型的异常，那么这个异常就会被抛出。因为这个异常会被抛出，所以必须在<code>try-catch-finally</code>所在的方法首部声明这个类型的异常（必须声明，编译器会检测到的）。</p><p>（5）<code>catch</code>部分也可能抛出新异常，分为两种情况：用于将原始异常==包装==为新异常、程序执行错误导致抛出新异常。无论哪种情况，都必须在方法首部声明这个重新抛出的异常类型。</p><p>2、<code>finally</code>部分</p><p>（1）这部分可以没有。</p><p>（2）无论发生什么情况，<code>finally</code>部分的代码都一定会被执行，==但未必能够全部执行==。</p><p>（3）这部分是为了清理资源。比如在读取文件时发生了错误，抛出了异常，然后<code>catch</code>部分捕获了异常，但是处理完异常后可能会改变程序执行顺序，也可能会退出程序，无论哪种情况，都有可能损坏文件，因为文件被打开后没有被正确关闭，所以我们应该保证即使读取文件时发生了错误，也能正确关闭文件。这就是清理资源。</p><p>==<code>finally</code>部分是用来清理资源的，代码块中不要有<code>return</code>等转移控制流的语句，同时还要确保<code>finally</code>部分的代码不会抛出异常。==</p><h5 id="执行顺序" tabindex="-1">执行顺序 <a class="header-anchor" href="#执行顺序" aria-label="Permalink to &quot;执行顺序&quot;">​</a></h5><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">InputStream in </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // code that might throw exceptions</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(EOFException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 3</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // show error message which might throw new exceptions</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(FileNotFoundException | UnknownHostException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 5</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // show error message</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 6</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 7</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    in.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 8</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 9</span></span></code></pre></div><p>1、如果<code>try</code>部分的代码没有抛出异常，则程序会跳过<code>catch</code>部分：</p><p>（1）如果有<code>finally</code>部分，则执行顺序为<code>1 2 7 8 9</code>。</p><p>（2）如果没有<code>finally</code>部分，执行顺序为<code>1 2 9</code>。</p><p>2、如果<code>try</code>部分的代码抛出了一个其他类异常，则<code>catch</code>部分无法捕获到这个异常且这个异常最终会被该方法抛出：</p><p>（1）如果有<code>finally</code>部分，则执行顺序为<code>1 7 8</code>，然后该方法会向调用它的上层方法抛出这个异常，直到遇到某个提供了异常处理器（<code>catch</code>）的上层方法，会按相同逻辑处理这个异常；如果mei有方法提供异常处理器，那么程序终止。</p><p>（2）如果没有<code>finally</code>部分，则执行顺序为<code>1</code>，然后该方法会向调用它的上层方法抛出这个异常，直到遇到某个提供了异常处理器（<code>catch</code>）的上层方法，会按相同逻辑处理这个异常；如果mei有方法提供异常处理器，那么程序终止。</p><p>3、如果<code>try</code>部分的代码抛出了一个<code>FileNotFoundException</code>或<code>UnknownHostException</code>类异常，则<code>catch</code>部分会捕获到这个异常并进行处理：</p><p>（1）如果有<code>finally</code>部分，则执行顺序为<code>1 5 6 7 8 9</code>。</p><p>（2）如果没有<code>finally</code>部分，则执行顺序为<code>1 5 6 9</code>。</p><p>4、如果<code>try</code>部分的代码抛出了一个<code>EOFException</code>类异常，则<code>catch</code>部分会捕获到这个异常并正确处理：</p><p>（1）如果有<code>finally</code>部分，则执行顺序为<code>1 3 4 7 8 9</code>；</p><p>（2）如果没有<code>finally</code>部分，则执行顺序为<code>1 3 4 9</code>。</p><p>5、如果<code>try</code>部分的代码抛出了一个<code>EOFException</code>类异常但<code>catch</code>部分捕获到这个异常后处理时又引发了新异常，则这个新异常最终会被该方法抛出：</p><p>（1）如果有<code>finally</code>部分，则执行顺序为<code>1 3 7 8</code>，然后该方法会向调用它的上层方法抛出这个新异常，直到遇到某个提供了异常处理器（<code>catch</code>）的上层方法，会按相同逻辑处理这个异常；如果mei有方法提供异常处理器，那么程序终止。</p><p>（2）如果没有<code>finally</code>部分，则执行顺序为<code>1 3</code>，然后该方法会向调用它的上层方法抛出这个新异常，直到遇到某个提供了异常处理器（<code>catch</code>）的上层方法，会按相同逻辑处理这个异常；如果mei有方法提供异常处理器，那么程序终止。</p><p>6、如果没有<code>catch</code>部分，则如果抛出了异常，这个异常最终或被该方法抛出：</p><p>（1）如果有<code>finally</code>部分，则执行顺序为<code>1 7 8</code>，然后该方法会向调用它的上层方法抛出这个异常，直到遇到某个提供了异常处理器（<code>catch</code>）的上层方法，会按相同逻辑处理这个异常；如果mei有方法提供异常处理器，那么程序终止。</p><p>（2）如果没有<code>finally</code>部分，则执行顺序为<code>1</code>，然后该方法会向调用它的上层方法抛出这个异常，直到遇到某个提供了异常处理器（<code>catch</code>）的上层方法，会按相同逻辑处理这个异常；如果mei有方法提供异常处理器，那么程序终止。</p><p>7、上面六种情况都是假设<code>finally</code>部分能够正确执行的。</p><p>但是如果程序执行到<code>finally</code>部分的代码<code>7</code>时：抛出了一个新异常（无论是<code>throw</code>显示抛出的还是程序执行引发的）或者执行<code>return</code>等转移控制流的语句，那么：</p><p>（1）如果之前的代码有原始异常（可能是未被<code>catch</code>捕获到的异常，也可能是<code>catch</code>块抛出的异常）要抛出，那么：这个原始异常会被<code>finally</code>部分抛出的新异常覆盖（”吞掉“）；</p><p>（2）如果之前的<code>try</code>块中没有抛出异常，且<code>try</code>块中最后要<code>return</code>一个值，那么：这个值会被<code>finally</code>部分抛出的新异常覆盖（”吞掉“）。</p><p>因此：要牢记==<code>finally</code>部分是用来清理资源的，代码块中不要有<code>return</code>等转移控制流的语句，同时还要确保<code>finally</code>部分的代码不会抛出异常。==</p><p>为了确保<code>finally</code>能够正确清理资源，可以这么写代码。这样还会报告<code>finally</code>部分出现的错误。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">InputStream in </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(EOFException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(FileNotFoundException | UnknownHostException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        in.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(IOException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="try-with-resources语句" tabindex="-1"><code>try-with-resources</code>语句 <a class="header-anchor" href="#try-with-resources语句" aria-label="Permalink to &quot;\`try-with-resources\`语句&quot;">​</a></h3><p>1、<code>try-with-resources</code>语句主要用于资源文件的读取操作，确保读取文件时即使发生错误也能够正确关闭，不会导致文件损坏。</p><p>2、要求：表示资源文件的对象必须是实现了<code>AutoCloseable</code>接口的类实例。<code>AutoCloseable</code>接口只有一个方法：<code>void close() throws Exception</code>。</p><p>3、这个语句能够保证：无论<code>try</code>语句中抛出了什么异常，在退出<code>try</code>块之前，都会自动调用<code>res1.close()</code>和<code>res2.close()</code>方法。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// res1 res2未必是Resource类对象，可以是实现了\`AutoCloseable\`接口的任意类对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Resource res1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...， Resource res2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // work with res</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Exception </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>4、<code>try-with-resourecs</code>语句后面还可以有<code>catch</code>和<code>finally</code>部分。在执行完<code>finally</code>部分代码（未抛出异常）或<code>close</code>方法（抛出了异常）之后，会继续执行<code>catch</code>（如果抛出了异常就会执行）和<code>finally</code>部分代码（只要有代码都会执行）。</p><p>5、如果<code>try</code>部分抛出了异常，执行<code>close</code>方法时又抛出了新异常，那么：原始异常<code>e</code>会被重新抛出，而<code>close</code>方法抛出的新异常会被”抑制“：自动调用<code>Throwable</code>类对象的<code>addSuppressed(Throwable t)</code>将<code>close</code>方法抛出的新异常添加进原始异常。之后，我们可以使用<code>e.getSuppressed()</code>方法获取<code>close</code>方法中被抑制的所有异常数组。</p><h3 id="分析堆栈元素轨迹" tabindex="-1">分析堆栈元素轨迹 <a class="header-anchor" href="#分析堆栈元素轨迹" aria-label="Permalink to &quot;分析堆栈元素轨迹&quot;">​</a></h3><p>==堆栈轨迹==是程序执行过程中某个特定点上所有挂起的方法调用的一个列表。</p><p>1、可以使用<code>Throwable</code>类的<code>printStackTrace</code>方法访问堆栈轨迹的文本描述信息。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            TestClass ts </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TestClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ts.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Exception </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(System.out);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(System.err);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TestClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throws</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Exception{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FileNotFoundException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>运行结果如下图所示：</p><p><img src="`+p+`" alt="堆栈元素轨迹"></p><p>2、一种更灵活的方法是使用<code>StackWalker</code>类，它会生成一个<code>StackWalker.StackFrame</code>实力流，其中每个实例分别描述一个栈帧。可以使用<code>forEach</code>方法操作迭代处理这些栈帧。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            TestClass ts </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TestClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ts.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Exception </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TestClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throws</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Exception{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        StackWalker walker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> StackWalker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		walker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(System.out</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">println);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FileNotFoundException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/** 输出结果为：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">TestJava.TestClass.test(Test.java:168)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">TestJava.Test.main(Test.java:42)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">java.io.FileNotFoundException</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">*/</span></span></code></pre></div><h3 id="异常包装技术" tabindex="-1">异常包装技术 <a class="header-anchor" href="#异常包装技术" aria-label="Permalink to &quot;异常包装技术&quot;">​</a></h3><p>异常包装就是将原始异常设置为新异常的原因，然后抛出新异常。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SQLException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">original</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ServletException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;database error&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initCause</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(original);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    throw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>捕获到这个异常时，可以使用<code>e.getCause()</code>获取原始异常。</p><h3 id="异常使用技巧" tabindex="-1">异常使用技巧 <a class="header-anchor" href="#异常使用技巧" aria-label="Permalink to &quot;异常使用技巧&quot;">​</a></h3><p>1、异常处理不能代替简单的测试</p><p>2、==不要过分细化异常==</p><p>一般而言当出现任何一种异常时都会取消任务，这种情况下异常类型的意义并不是很大。</p><p>3、==充分利用异常层次结构==</p><p>如果能够将一种异常转换成另一种更适合的自定义异常，那么不要犹豫。</p><p>4、==不要压制异常==</p><p>不要在<code>catch</code>部分什么也不处理，起码要打印出消息，否则它会被悄无声息地忽略。</p><p>5、==早抛出，晚捕获==</p><p>（1）早抛出：是为了能够获得最真实详细的错误原因。例如，当栈为空时，<code>Stack.pop()</code>方法该抛出一个异常还是返回<code>null</code>？我们认为最好在出错的地方直接抛出一个<code>EmptyStackException</code>异常，这要好于以后抛出一个<code>NullPointerException</code>异常。因为<code>NullPointerException</code>异常并不够详细，我们还需要进一步的排查。</p><p>（2）晚捕获：除非某个方法确定应该怎么处理异常，否则尽量将它抛出给调用它的方法。这样只有传递给合适的方法后，由它来根据任务逻辑决定怎么处理。</p><h2 id="断言" tabindex="-1">断言 <a class="header-anchor" href="#断言" aria-label="Permalink to &quot;断言&quot;">​</a></h2><p>断言机制允许在测试期间向代码中插入一些检查，而在生产代码中会自动删除这些检查。</p><p><code>assert condition;</code>或<code>assert condition: expression;</code></p><p>这两个语句都会计算<code>condition</code>，如果结果为<code>false</code>，则抛出一个<code>AssertionError</code>异常。在第二个语句中，表达式将传入<code>AssertionError</code>对象的构造器，并转换成一个消息字符串。应注意：<code>AssertionError</code>对象并不存储具体的表达式值，因此以后无法得到这个表达式值。</p><h3 id="启用和禁用断言" tabindex="-1">启用和禁用断言 <a class="header-anchor" href="#启用和禁用断言" aria-label="Permalink to &quot;启用和禁用断言&quot;">​</a></h3><p>1、通过命令行启用或禁用断言</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">//</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 运行MyApp，启用所有断言</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -enableassertions</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> MyApp</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">//</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> enableassertions可简写为ea</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ea</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> MyApp</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">//</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 运行MyApp,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 启用</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> MyClass类</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 和</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> com.mycompany.mylib包及其子包的所有类</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 的断言</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ea:MyClass</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ea:com.mycompany.mylib</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> MyApp</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">//</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 运行MyApp,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 启用</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> MyClass类</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 的断言，禁用</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> com.mycompany.mylib包及其子包的所有类</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 的断言</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ea:MyClass</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -disableassertions:com.mycompany.mylib</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> MyApp</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">//</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> disableassertions可简写为da</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ea:MyClass</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -da:com.mycompany.mylib</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> MyApp</span></span></code></pre></div><p>启用或禁用断言是类加载器的功能，与编译器无关，但启用或禁用断言开关不能应用到那些没有类加载器的“系统类”上。</p><p>2、通过编程控制类加载器的断言状态</p><p>参见<code>java.lang.ClassLoader</code>类。</p><h3 id="启用断言的情况" tabindex="-1">启用断言的情况 <a class="header-anchor" href="#启用断言的情况" aria-label="Permalink to &quot;启用断言的情况&quot;">​</a></h3><p>什么时候应该启用断言呢？如果方法的文档中这样指出：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> a</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> the array to be sorted(must not be null).</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">*/</span></span></code></pre></div><p>那么对<code>null</code>数组调用这个方法是不合法的，因此在调用这个方法时，就应该提前使用断言：<code>assert a != null;</code>。否则，这个方法就会“为所欲为”。</p><p>如果文档中没有明确指出参数<code>a</code>不能为<code>null</code>，也就是没有指出<code>a</code>为<code>null</code>时该采取什么行动，那么在这种情况下，可以认为这个方法仍然会成功返回，而不会抛出一个异常。因此，就不应该使用断言。</p>`,137),t=[h];function k(d,c,o,E,r,y){return a(),i("div",null,t)}const u=s(l,[["render",k]]);export{F as __pageData,u as default};
