# 普通索引和唯一索引

举例说明：假设字段k上的值都不重复。InnoDB的索引组织结构如下所示：

![image](/pictures/mysql/chap8/1.png)

以下主要从性能的角度来考虑采用唯一索引还是普通索引？（查询语句和更新语句）

## 查询过程

假设，执行查询的语句是 select id from T where k=5；这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。

- 对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，**需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录**。
- 对于唯一索引来说，由于索引定义了唯一性，**查找到第一个满足条件的记录后，就会停止继续检索**。

这两种索引方式在查询过程中性能差距微乎其微，原因是：

- InnoDB 的数据是按数据页为单位来读写的，当找到 k=5 的记录的时候，它所在的数据页就都在内存里了。
- 对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。

## 更新过程

### change buffer

- 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会**将这些更新操作缓存在 change buffer 中**，这样就不需要从磁盘中读入这个数据页了
- 在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作
- change buffer是可以持久化的数据，即change buffer 在内存中有拷贝，也会被写入到磁盘上
- **将 change buffer 中的操作应用到原数据页**，得到最新结果的过程称为 merge
- 除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。

change buffer的**使用条件**：

- 唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用
- change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。

如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB 的处理流程如下：

1. 这个记录要更新的目标页在内存中。InnoDB 的处理流程如下：
- 对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；
- 对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。

2. 这个记录要更新的目标页不在内存中。InnoDB 的处理流程如下：
- 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
- 对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。

<mark>唯一索引由于需要将数据从磁盘读取内存，导致其更新操作耗费巨大；而普通索引运用change buffer，减少了随机磁盘访问，提升更新性能。</mark>

## change buffer的使用场景

change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。

- 因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是**账单类、日志类的系统**。
- 而对于更新模式为写入之后马上会做查询的业务模式，随机访问 IO 的次数不会减少，**反而增加了 change buffer 的维护代价**，change buffer 反而起到了副作用。

## 索引选择和实践

- 尽量选择普通索引，在实际使用中，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的
- 如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。
- 特别地，在使用机械硬盘时，change buffer 这个机制的收效是非常显著的：把 change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。

## change buffer 和 redo log

现执行插入语句，如下所示：
```sql
mysql> insert into t(id,k) values(id1,k1),(id2,k2);

```

假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (InnoDB buffer pool) 中，k2 所在的数据页不在内存中。带 change buffer 的更新状态图如下所示：

![image](/pictures/mysql/chap8/2.png)

该操作涉及四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）

这条更新语句做了如下的操作（按照图中的数字顺序）：
1. Page 1 在内存中，直接更新内存；
2. Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息；
3. 将上述两个动作记入 redo log 中（图中 3 和 4）。

**注**：图中的两个虚线箭头，是后台操作，不影响更新的响应时间。

当在这个操作之后进行相应的读操作：select * from t where k in (k1, k2)。则带change buffer的读操作流程图如下所示：

![image](/pictures/mysql/chap8/3.png)

1. 读 Page 1 的时候，直接从内存返回。
2. 要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，**然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果**。

因此，如果要简单地对比这两个机制在提升更新性能上的收益的话，<mark>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。</mark>