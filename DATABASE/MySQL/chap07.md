# 事务是否需要隔离

可重复读隔离级别下，执行行锁时，事务在获取到行锁要更新数据时，读到的数据会是什么？

## 示例说明

以下是只有两行表的初始化语句

```sql 
mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
```

### 注意事项

- begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句（第一个快照读语句），事务才真正启动。
- autocommit默认为1，则一个语句的执行本身就是一个事务，在语句完成后将会自动提交

![image](/pictures/mysql/chap7/1.png)

<mark>在这种情况下，事务B查到的k的值是3，而事务A查到的k的值是1</mark>；

事务B在更新了行之后查询; 事务A在一个只读事务中查询，并且时间顺序上是在事务B的查询之后。

MySQL中存在两个“视图”的概念：

- 一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view ... ，而它的查询方法与表一样。

- 另一个是**InnoDB在实现MVCC时用到的一致性读视图**，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。

## “快照”在MVCC里是怎么工作的？


在可重复读隔离级别下，事务在启动时进行快照。这个快照是**基于整库的**。


### 快照是如何实现的？

- <mark>InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id</mark>。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。
- 每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。
- 同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它

如图所示，一个记录被多个事务连续更新后的所有状态

![image](/pictures/mysql/chap7/2.png)

- 图中虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id 为25的事务更新的，因此它的row trx_id也是25。
- 图中中的三个虚线箭头，就是undo log（回滚日志）
- V1、V2、V3并不是物理上真实存在的，而是**每次需要的时候根据当前版本和undo log计算出来的**。

### InnoDB如何定义快照

事实上，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。但上一个版本不存在，则会继续往前检索。

- 在实现上， InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。**活跃”指的就是，启动了但还没提交**
- 数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的<mark>事务ID的最大值加1记为高水位</mark>。   
- 这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）
- 数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的

![image](/pictures/mysql/chap7/3.png)

对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能:

1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果落在黄色部分，那就包括两种情况

    a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；

    b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。

而系统后面的更新下，生成的版本一定属于上面的2或者3(a)的情况，对于当前的事务来说，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的。

因此，**InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力**。

*** 分析示例中事务A返回的结果为什么k=1?

假设：

1. 事务A开始前，系统里面只有一个活跃事务ID是99；
2. 事务A、B、C的版本号分别是100、101、102，且当前系统里只有这四个事务；
3. 三个事务开始前，(1,1)这一行数据的row trx_id是90。

事务A的视图数组就是[99,100], 事务B的视图数组是[99,100,101], 事务C的视图数组是[99,100,101,102] 。而事务A查询逻辑如下所示：

![image](/pictures/mysql/chap7/4.png)

- 从图中可以看到，第一个有效更新是事务C，把数据从(1,1)改成了(1,2)。这时候，这个数据的最新版本的row trx_id是102，而90这个版本已经成为了历史版本。
- 第二个有效更新是事务B，把数据从(1,2)改成了(1,3)。这时候，这个数据的最新版本（即row trx_id）是101，而102又成为了历史版本。
- 事务A查询的时候，其实事务B还没有提交，但是它生成的(1,3)这个版本已经变成当前版本了，因此该版本对事务A是不可见的，否则会**脏读**
- 事务A查询语句的读数据流程:
    - 找到(1,3)的时候，判断出row trx_id=101，比高水位大，处于红色区域，不可见；
    - 接着，找到上一个历史版本，一看row trx_id=102，比高水位大，处于红色区域，不可见；
    - 再往前找，终于找到了（1,1），它的row trx_id=90，比低水位小，处于绿色区域，可见。

则相应的，一个数据版本对于一个事务视图来说，有三种情况：

1. 版本未提交，不可见；
2. 版本已提交，但是是在视图创建后提交的，不可见；
3. 版本已提交，而且是在视图创建前提交的，可见。

## 更新逻辑

事务B的更新逻辑图如下所示：

![image](/pictures/mysql/chap7/5.png)

事务B在更新操作之前执行查询操作，而得到的结果为k=1；而执行更新操作时，不能再在历史版本上（k=1）更新，否则事务C的更新就丢失了。因此，此时事务B的更新是在事务C的更新执行（1，2）的基础上来进行的。

所使用的规则：更新数据都是先读后写的，**而这个读，只能读当前的值，称为“当前读”（current read）**

因此，在更新的时候，**当前读**拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本的row trx_id是101。
在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的k的值是3。

假设事务C不是马上提交的，而是变成了下面的事务C’，即：

![image](/pictures/mysql/chap7/6.png)

此处，便使用两阶段锁协议进行处理：事务C’没提交，也就是说(1,2)这个版本上的写锁还没释放；而事务B是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，**必须等到事务C’释放这个锁，才能继续它的当前读**。

- 可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。
- 如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：
- 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
- 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。

普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的可见性。
- 对于可重复读，查询只承认在**事务**启动前就已经提交完成的数据；
- 对于读提交，查询只承认在**语句**启动前就已经提交完成的数据；

<mark>注意的点：</mark>

- Innodb 要保证这个规则：事务启动以前所有还没提交的事务，它都不可见。
- 只存一个已经提交事务的最大值是不够的，一些比最大值小的事务也有可能更新。
- 事务启动时还会保存“现在正在执行的所有事物ID列表”，如果一个row trx_id在这列表中，也要不可见。
