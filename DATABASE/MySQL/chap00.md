# MySQL底层数据结构：B+树

## B树

B-树,这里的 B 表示 balance( 平衡的意思),B-树是一种多路自平衡的搜索树（B树是一颗多路平衡查找树）。简化图如下所示：

![image](/pictures/mysql/b+/1.png)

B-树有如下特点:
- 所有键值分布在整颗树中（索引值和具体data都在每个节点里）;
- 任何一个关键字出现且只出现在一个结点中；
- 搜索有可能在**非叶子结点**结束（最好情况O(1)就能找到数据）；
- 在关键字全集内做一次查找,性能逼近二分查找。

### B树的由来

**B-树是专门为外部存储器设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中**。

其他AVL、红黑树这类平衡二叉树为什么从设计上无法迎合磁盘？

- 平衡二叉树是通过旋转来保持平衡的，而旋转是对整棵树的操作，若部分加载到内存中则无法完成旋转操作。
- 平衡二叉树的高度相对较大为 log n（底数为2），这样逻辑上很近的节点实际可能非常远，**无法很好的利用磁盘预读（局部性原理）**

B树的设计：

索引的效率依赖于磁盘 IO 的次数，快速索引需要有效的减少磁盘 IO 次数，如何快速索引呢？索引的原理其实是不断的缩小查找范围

- B-树每次将范围分割为多个区间，区间越多，定位数据越快越精确;
- 如果节点为区间范围，每个节点就较大了。
- 所以新建节点时直接**申请页大小的空间**，计算机内存分配是按页对齐的，这样就实现了一个节点只需要一次 IO。
- 多叉会有效降低B-树的高度，提高范围缩小的速度。

### B-树的查找

B-树在查找时会从根节点开始，对key进行二分查找，当需要进入下一层时，进行一次磁盘IO来读取数据，再重复上述过程，直至找到key为止。

## B+树

与 B- 树的不同之处在于:

- 所有关键字存储在叶子节点出现,内部节点(**非叶子节点并不存储真正的 data**)
- 为所有叶子结点增加了一个链指针

![image](/pictures/mysql/b+/2.png)

因为内节点并不存储 data，所以一般B+树的叶节点和内节点大小不同，而B-树的每个节点大小一般是相同的，为一页。

### B+树和B-树的区别
1. B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n，都必须从根节点索引至叶子节点。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。
2. B+树叶节点两两相连可大大增加区间访问性，**可使用在范围查询等**，而B-树每个节点 key 和 data 在一起，则无法区间查找。
空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。

![image](/pictures/mysql/b+/3.png)

- B+树则可以通过磁盘预读原理提前将这些数据读入内存，减少了磁盘 IO 的次数，从而很好地利用空间局部性原理。
- 由于B+树的叶子节点的数据都是使用链表连接起来的，而且他们**在磁盘里是顺序存储的**，所以当读到某个值的时候，磁盘预读原理就会提前把这些数据都读进内存，使得范围查询和排序都很快
3. B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确。

- B+树节点只存储 key 的副本，真实的 key 和 data 域都在叶子节点存储。
- 磁盘是分 block 的，一次磁盘 IO 会读取若干个 block，具体和操作系统有关，那么由于磁盘 IO 数据大小是固定的，在一次 IO 中，单个元素越小，量就越大。
- 因此，B+树单次磁盘 IO 的信息量大于B-树，从这点来看B+树相对B-树磁盘 IO 次数少。

## MySQL为什么使用B-Tree（B+Tree）&& 存储知识

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。然而，这样的方式会导致索引查找过程中产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级。因此，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。

### 存储数据最小单元

- 扇区：磁盘存储数据最小单元是扇区，一个扇区的大小是512字节。
- 页（page）：页是磁盘存储的最小单元，每个页的大小一般为16KB。
- 块（block）：块是文件系统分配的最小单元，一般为4KB。

![image](/pictures/mysql/b+/4.png)

数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一行数据的大小是1k，那么一个页可以存放16行这样的数据。

### 主存存取原理

目前计算机使用的主存基本都是随机读写存储器（RAM）。

- 从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。
- 每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。

主存的存取过程如下：

- 当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。
- 写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。

### 磁盘存取原理

与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。

![image](/pictures/mysql/b+/5.png)

- 盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个**磁道**，所有半径相同的磁道组成一个**柱面**。
- 磁道被沿半径线划分成一个个小的段，每个段叫做一个**扇区**，每个扇区是磁盘的最小存储单元。

从磁盘读取数据：

- 当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路**按照寻址逻辑将逻辑地址翻译成物理地址**，即确定要读的数据在哪个磁道，哪个扇区。
- 为了读取这个扇区的数据，需要磁头放到这个扇区上方，因此需要移动磁头来对准相应磁道，这个过程叫做寻道，所耗费时间叫做**寻道时间**，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做**旋转时间**。

### 局部性原理与磁盘预读

由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。

<mark>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</mark>

- 预读的长度一般是页的整数倍
- 页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。
- 当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中

**因此，IO一次就是读一页的大小**

