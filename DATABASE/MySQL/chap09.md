# MySQL为什么会选错索引？

举例说明：
假设表里有a、b两个字段，并分别建上索引：

```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `a` (`a`),
  KEY `b` (`b`)
) ENGINE=InnoDB；
```
现往表t中插入10万行记录，取值按整数递增。而当做如下操作：

![image](/pictures/mysql/chap9/1.png)

- session A 开启了一个事务；随后，session B 把数据都删除后，又调用了 idata 这个存储过程，插入了 10 万行数据。
- session B 再进行查询操作： select * from t where a between 10000 and 20000 

结果中，session B在执行查询操作时没有选择索引a，导致了更长的执行时间，共扫描了10万行。

## 优化器的逻辑

优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。

- 在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。
- 扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。

### 扫描行数的判断

MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。
- 而统计信息就是索引的**区分度**，一个索引上不同的值越多，这个索引的区分度就越好。
- 而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。

### 如何得到索引的基数

采样统计的**动机**：如果把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了

- 采样统计时，InnoDB 默认会选择 N 个数据页，**统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数**。
- 当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。

MySQL中，有两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent 的值来选择：
- 设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。
- 设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。

优化器不全是根据索引统计值来进行判断，还需要判断执行这个语句本身需要扫描多少行。

![image](/pictures/mysql/chap9/2.png)

以上结果为优化器预估两个语句的扫描行数结果：(rows 字段表示的是预计扫描行数)
- Q1结果还是符合预期的，rows 的值是 104620；
- Q2 的 rows 值是 37116，偏差就大了

优化器选择执行扫描行数为100000的执行计划的原因：
- 如果使用索引 a，每次从索引 a 上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。
- 如果选择扫描 10 万行，是直接在主键索引上扫描的，没有额外的代价。
- 优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。

因此，MySQL选错索引归根结底是没能准确地判断出扫描行数

而在实践中，可用 analyze table t 命令来重新统计索引信息：

![image](/pictures/mysql/chap9/3.png)

事实上，因为优化器不只是根据扫描行数来进行判断，所以可通过analyze命令来解决很多问题。

## 索引选择异常和处理

### 第一种方法：采用force index 强行选择一个索引

MySQL 会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。**如果 force index 指定的索引在候选索引列表中，就直接选择这个索引**，不再评估其他索引的执行代价。

但这种方式存在以下问题：
- 如果索引改了名字，则相应的语句也得修改
- 如果以后迁移到别的数据库的话，这个语法还可能会不兼容。
- 最主要的问题是变更的及时性：出现问题时加上force index来进行修改，但是等到下次测试时就还需要进行修改，这种方式对于生产系统来说不够敏捷。

### 第二种方法：考虑修改语句，引导MySQL使用我们期望的索引

对于以下例子来说：

```sql
mysql> explain select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;
```

如果将order by b limit 1” 改成 “order by b,a limit 1”，效果会得到提升。

- 之前优化器选择使用索引 b，是因为它认为使用索引 b 可以避免排序（b 本身是索引，已经是有序的了，如果选择索引 b 的话，不需要再做排序，只需要遍历），所以即使扫描行数多，也判定为代价更小。
- 现在 order by b,a 这种写法，要求按照 b,a 排序，就意味着**使用这两个索引都需要排序**。<mark>因此，扫描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描 1000 行的索引 a。</mark>

### 第三种方法：在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。

